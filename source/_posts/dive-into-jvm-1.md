---
title: 深入浅出 Java 虚拟机（一）
tags: 
date: 2018-11-01 21:03:00
desc: 《深入理解 Java 虚拟机》 读书笔记
---

最近读了一本书，《深入理解 Java 虚拟机》，我认为写得非常好，感觉这本书为我打开了一个新的世界。虽然作为一个应用层开发人员，大多数时候我们是不需要理解底层虚拟机的运行机制的，事实上，这正是 Java 虚拟机设计的优秀之处，对开发人员完全屏蔽了运行时的绝大多数细节。但正是如此，我觉得我们更应该深入探索 JVM 。

<!-- More -->

## Java 虚拟机所使用的进程

一个虚拟机实例运行在一个操作系统进程之上。


## 术语定义

1. Slot： 局部变量空间单位

## 对 Java 虚拟机所使用的内存区域进行划分

### 线程专属的内存区域
虚拟机栈（VM Stack），本地方法栈（Native Method Stack），程序计数器（Program Couter Register）

### 非线程专属的内存区域
方法区、堆

## 程序计数器
1. 当前程序所执行的字节码的行号指示器。
2. 字节码解释器工作室就是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复都需要依赖这个计数器来完成。
3. 唯一一个在规范中没有定义 OutOfMemoryError 的区域。
4. 因为我们的程序是多线程环境，所以这块需要存在于线程私有区域。
5. 如果执行的是 Native 方法，计数器值为空。

## 虚拟机栈（VM Stack）
1. 也是线程私有的，声明周期与线程相同。
2. 描述的是 Java **方法执行时** 的内存模型，每个方法被执行的时候都会同时创建一个栈帧（Stack Frame），用于存储局部变量表、操作栈、动态链接、方法出口等信息。
3. 每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
4. 大家常说的 “堆栈” 中的 “栈” 指的就是虚拟机栈，或者是虚拟机栈中的局部变量表部分。
5. 局部变量表存储的是基本数据类型和对象引用类型（但是真正对象空间在堆分配，这里仅仅是一个指针）和returnAddress 类型。
6. 局部变量表所需的内存空间在编译期分配完成，运行期局部变量表的大小不会发生变化。
7. 当栈深度大于 JVM 所允许的深度时，抛出 StackOverflow 异常，当栈动态扩展但是无法申请到足够的内存时会抛出 OutOfMemoryError 异常。

## 本地方法栈（Native Method Stacks）
1. 也会抛出 StackOverflowError 和 OutOfMemoryError。

## 堆

1. 是 JVM 所管理的内存中最大的一块，是被所有线程共享的一块内存区域，此区域的唯一目的就是存放对象实例。
2. 随着栈上分配等技术，并不是所有对象都在堆上分配。“所有对象都在堆上分配”不绝对。
3. 堆可细分为新生代和老年代。再细分有 Eden 空间，From Survivor 空间，To Surivor 空间。
4. 堆从线程的角度可以划分出多个线程私有的分配缓冲区
5. 堆在逻辑上连续，但是物理上可以不连续。

## 方法区
1. 和堆一样，是各个线程共享的内存区域。
2. 存储已被虚拟机加载的类信息、常量、静态变量、JIT编译后的代码，在虚拟机规范中把方法区描述为 **堆的一个逻辑部分**，但是有个别名 Non-Heap 目的是和堆区分开来。
3. HotSpot 上很多人愿意把方法区称为永久代。原因是 HotSpot 团队选择把 GC 分代收集扩展至方法区，使用永久代来实现方法区而已。很多JVM（J Rockit IBM J9 不存在永久代的概念，永久代可能搬家到 Native Memory）
4. 本区域的内存回收目标针对常量池的回收和类对型的卸载。
5. 到无法满足内存分配需求时，将跑出OOM。

## 运行时常量池

1. 是方法区的一部分。在 Class 文件中，除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这些内容将在类加载后存放到方法区的运行时常量池中。
2. 除了 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。
3. 运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性，JVM 不要求常量一定只能在编译器产生，运行期间也可能将新的常量放入池中。String.intern() 方法
4. 当常量池无法再申请到内存是会 OOM 

问题：
1. 理解 jdk 7 前后 String.intern() 方法的区别

## 直接内存

1. 直接的 Native 内存，NIO 会用到，避免在 Java 堆和 Native 堆中来回复制数据，提高性能
2. 也会 OOM

问题：
1. NIO 是如何使用直接内存的？


## 对象访问

reference 类型的数据结构：

1. 句柄方式： 存在一个句柄池，reference 指向句柄池中的一个句柄，句柄内部包含两部分（到对象实例数据的指针，到对象类型数据的指针）。
2. 直接指针： reference 直接指向对象实例数据，但是在对象实例数据内部额外存放一个指针指向对象类型数据。

句柄方式好处是 GC时（对象移动的场合），reference 本身不需要改，只需要改句柄中的到对象实例数据的指针。

直接指针访问方式的好处是速度快，节省一次指针定位的时间开销。因为从 referenc 到获得真正对象数据和类型，句柄需要定位3次，直接指针只需要定位一次。

#垃圾回收

三个问题：哪些内存需要回收？什么时候回收？如何回收？

## 引用计数
1. 给对象添加一个引用计数器，有一个地方引用它时，+1，引用失效时，-1，任何时刻计数器都为 0 的对象是不可能再被使用的。

缺陷：很难解决对象之间循环引用的问题

## 根搜索算法
1. 通过一系列“GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连，即不可达时，证明此对象是不可用的。

2. 可作为 GC Roots 的对象包括下面几种： 
a: VM Stacks(栈帧中俄本地变量表)中的引用的对象
b: 方法区中类静态属性引用的对象
c: 方法区中的常量引用的对象
d: 本地方法栈中JNI引用的对象

3. 引用分为：强引用、软引用、弱引用、虚引用。强度依次减弱

软引用： 



## 回收方法之标记-清除算法
空间问题，不连续
效率问题，标记和清除的效率都不高

## 回收方法之标记-复制算法
分为两块，用其中一块

商业虚拟机都用这种方法回收新生代
大的 Eden 空间 ，两块小的 Survivor 空间
8：1

## 回收方法之标记-整理算法
老年代


___
如果您对我的技术分享感兴趣，欢迎关注我的个人公众号：麻瓜日记，不定期更新原创技术分享，谢谢！:)

![](http://prototypez.github.io/images/qrcode.jpg)