
# 先做一下个人简介

我的学历是硕士，本科和硕士都是毕业于山东大学，硕士阶段是报送本校研究生，本科和硕士阶段专业都是软件工程。毕业时间是 2016年，到目前为止工作时间为两年。

## 工作中解决的一些问题

工作经历部分： 2015年-2016年（研三阶段）在百度上海研发中心实习，参与过两个项目，百度惠和百度Mall。
在百度惠这个项目中负责的是 Android 客户端的研发工作

在百度Mall中参与的部分前端 FE 的开发工作

毕业之后第一份工作，也就是目前在职的公司是证通股份有限公司，我们这个公司是由72家主流券商为股东发起成立的股份制公司，定位为证券行业基础设施。我们开发了一个一站式金融理财 App ，叫做证通财富，我就是这个 App 的核心研发人员，从入职开始到今年年初是在负责这个 App 的研发迭代工作。

此外我是一个比较喜欢开源项目的人，平时也喜欢自己维护开源项目，写一些技术博客分享在网络上。我想把我做过的工作分成两部分介绍，一部分是在开源领域的工作，另一部分是在公司具体实际的项目里的工作。

## Github 开源情况

在 Github 上维护 3 个 Android 项目，累计获得约 1.2k Star，单项目最高 Star 数为 800+
为这 3 个项目累计解决 20+ 个 issue，发布 10 余次新版本。

> 具体介绍一下这些开源项目解决的问题

## AppJoint

问题背景： 这是一套项目组件化的方案，是为了解决证通财富开发过程中面临的实际的痛点而生的  。具体来说就是随着项目越来越大，业务功能间的耦合越来越严重，编译速度越来越慢，开发效率降低，势必需要对项目进行拆分，分成若干个子业务模块进行单独开发调试，最后在 release 的时候合并为一个 App 进行发布。但是使用现有官方的模块的开发方案存在一些问题，
1. 比如拆分业务功能之后，业务模块如果逻辑上是平级的，互相调用就成了问题
2. 拆分模块不能影响目前的业务功能迭代，我们需要渐进式的组件化
3. 如何平和单独调试与传统和合并起来开发
上面是几个主要的问题，当然还有一些其他的细节问题，暂时不表
解决方案：
1. 模块之间的调用，利用 Gradle 的 Transform Api，在编译时对字节码做修改，模块之间通过接口彼此调用对方的功能，而接口真正的实现在模块自己内部，别的模块是不可见的，字节码修改的作用就是在编译时吧接口和实现建立关系，保证最后模块间可以顺利的进行互相调用

2. 关于单独调试与渐进式组件化的问题也是通过 Transform Api,在全量编译期间，保证主 App 的初始化动作进行的时候，各个子模块的初始化动作也能被调用到，通过注解建立关联。而各个子模块的初始化写法和主模块一样，保证开发体验的一致性和降低学习成本，同时由于这么做子模块比较容易被改造为可以单独编译运行的状态，提升了开发效率。

这套方案还有一些其他的细节工作，但是整体而言，是目前社区上学习成本最低的一套组件化方案，只有一个 api 和 3 个注解。可以最大限度不侵入组件化之前的开发方式，而社区其他的组件化方案为了能达到差不多的效果，都需要非常大的接入代价，目前这套方案发布 1 个月已经获得约 300 个 star 了。

## SaveState

问题背景：Android 里面必须小心处理 Activity / Fragment / View 的生命周期，为了正确恢复状态，程序员需要写很多模板代码例如， onSaveInstanceState, onRestoreInstanceState, 非常繁琐，而且维护不易。

解决方案：利用 APT 和 Transform API，只需要在需要被恢复的 Activity 类字段上标记一个 @AutoRestore 注解，剩下的事情程序帮你自动完成，提高了代码的鲁棒性还节省了程序员的经历和时间。这个项目比较受欢迎，目前 Github 上有800 + 个star

## Sq

问题背景：这个项目是为了解决经常会出现在App中的“流程”一类业务，比如说，登录流程、注册流程、实名认证流程、风险测评流程。流程可能是用户主动触发，也可能是进行某些操作由于条件不满足被动触发的。在开发流程一类业务时，面临一些问题，
1. 比如我们需要流程是可以复用的，也就是我们不能把流程最后一步完成后往哪里跳转写死。
2. 流程做完后是要能帮我们继续之前的操作的，而不是要用户再点一下
3. 流程必须对 Android 中的 Activity 等组件的生命周期友好，鲁棒性强
4. 写法优雅，不能像 onActivityResult 一样难以维护


解决方案：
1. 通过在 Activity 组件内部建一个不可见的 Fragment 来获得 Activity 的生命周期回调
2. 让这个 Fragment 去真正发起流程 startActivityForResult
3. 把 onActivityResult 回调封装成 RxJava 的 Observable
4. 利用 RxJava 的 Transformer 把一个业务流程封装成一个 ObservableTransformer
5. 利用 RxJava 的 compose 操作符一行就可以调用封装好的业务流程

最后的效果是，流程插入某个操作只需要一行代码，流程可以很容易的复用，流程之间可以随意组合，嵌套，最大限度满足业务逻辑。而且所有这一切生命周期安全，代码鲁棒性很强。而且流程完成可以自动继续用户之前被打断的操作，也可以自己随意指定跳转逻辑，非常方便。


以上是开源项目的介绍，除了 Github 上的开源项目以外，我也比较喜欢写一些技术博客和分享，一般选择发在自己的个人博客以及掘金上。

# 技术博客在掘金上的统计数据

4个月之前开始在掘金上写博客
8篇原创技术分享
获得阅读数 50000+
400+ 评论
1600+ 收藏
收获约 2000 粉丝

每一篇都得到掘金官方推送至掘金首页，掘金简书号，掘金微博

## 技术博客在技术周刊上的发表情况

技术博客多次在 AndroidWeekly 国际版与 AndroidWeeklky.cn 上发布。
其中《RxJava 沉思录》系列在多个知名 Android 技术公众号上转载



第二个块是我在公司项目中做的主要的工作：我们公司一开始 App 是请外包公司做的，有很多问题，比如说经常崩溃，卡顿，启动速度很慢，应用的 Apk 包比较大。
我做的工作可以从一下几个维度讲一下

1. 重构网络层
前面说到的崩溃问题就和网络层有直接关系，没有对异步任务做 Activity 生命周期的绑定，比如网络请求回调回来以后，前一个界面已经销毁了，这时候再做UI操作就可能导致崩溃。
此外，我们的网络层存在多种实现，需要在开发的时候进行切换，已有的方式切换不够灵活。

我重构的思路是在网络层之上构建一个抽象的网络层，对业务模块屏蔽网络层的具体实现，同时使用 RxJava 和 RxLifecycle 对网络请求绑定生命周期。一方面，由于引入抽象层，业务模块调用网络层的代码就十分稳定，不需要由于底层实现切换跟着修改代码，同时网络层使用了 Annotation Processor，帮助我们的开发少些很多模板代码，开发的时候也很轻松，只需要对接口进行注解即可，实现会自动生成。另一方面，由于生命周期的绑定，我们的异步网络操作就十分安全，崩溃率迅速降低，这是我入职以来做得第一件事情，领导很直观的看到了 App 质量的提升，对我的工作很满意，同时开发的工作也变轻松了。
后来我们的网络层进行过一次迁移，从 Worklight 切换到 HTTP，由于这层抽象层的存在，所以我们迁移工作非常平滑，没有影响任何开发工作，而且还可以在开发期间随时回退使用老的网络请求方式。

2. 重构存储层
第二块是存储层的优化，和网络层的思路是类似的，也是引入了存储的抽象层，对业务层屏蔽底层实现，存储分为两种，一是 KEY-VALUE 的，还有一块是 关系型数据库的，重构之前问题最大的是key-value存储，由于封装的抽象层次不够高，导致我们存储代码在项目中非常混乱，难以管理，也没有对业务层做隔离，经常导致一些非常难以排查的小bug。解决思路是吧存储有关逻辑都封装在几个固定的接口之中，存储层用接口向业务层暴露服务。这样我们的存储代码与业务代码的耦合消失了，而且高内聚的，维护起来轻松很多，bug 也消失了。


3. 项目组件化
前面开源的组件化方案，就是在这个项目中实践总结而来。组件化核心思想是对项目进行分拆，解耦，并行开发。这一块对业务来讲可能是无感知的，但是对于我们日常开发来讲的话，在组件化之前，我们整个大项目的编译时间常常超过10分钟，而一个开发人员一天需要编译的次数怎么也得20+次，原来我们浪费在编译上的时间是很可怕的。组件化之后，我们平时开发只需要对单个组件进行编译，编译时间小于1分钟，开启InstantRun以后最快可以在10s以内，这对于我们工作效率的提升是十分显著的。
同时在组件化之前，我们的跨模块方法调用写法非常不优雅，鲁棒性不够强。在使用组件化框架之后，单个组件对其他组件的服务调用就好像是在调用自身功能一样，一方面这样更简单，学习成本更低，另一方面，代码的鲁棒性更好，App 的质量也更有保证。

4. 业务流程代码的规范化

这块也是前面开源部分提到的 Sq 这个框架灵感的来源，其实金融理财类的 App 里流程特别多，流程嵌套组合也很多，以往的写法可复用性，鲁棒性都不够，代码也不够优雅，使用了 Sq 这个方案以后，所有问题都被解决了，开发流程对我们来说是一件很轻松的事情。

5. apk瘦身
这块的工作，由于先前外包公司留下的 App 项目的不合理，从直观感受来看，apk 从原先的近50m， 到了目前的20m+，主要解决的思路是，反向 ApkAnalyzer 解析 apk 包，分析包里可以优化的部分，可以优化的大头是图片、dex、so包、assets。
对于图片一方面是利用IDE的检查，以及人工检查去除项目中用不到的图片，另一方面，是对图片做 tinyPng 的压缩，这块我专门开发了一个python脚本用于对项目中的图片进行压缩，随后的效果是图片体积部分减少了 60% 以上，so 包部分，我们只保留一个架构的 so，以减少 apk 体积，dex 部分，我们启用 Progurad，assets 部分我们把平时很少用到的资源放到云端，由 App 按需加载。除了常规手段也用到三方工具，例如微信的 AndResguard 对 resources.arsc 进行混淆。

6. 冷启动优化
原先 App 启动经常会点击图标后卡在 launcher 没反应 3~4 秒，体验不是很好。我的处理思路是首先为应用设置一个 theme 显示 splash 界面，避免无任何响应。其次，对启动路径上的代码逻辑做减法，主要是 Application 的初始化和首个 Activity 的初始化动作，Application 里除了必要的操作，其余的按需加载，或者在子线程加载。首页的 Activity 如果比较复杂，也需要做延迟加载，Fragment 只加载第一个，其余的按需加载。网络请求的数据也缓存起来，保证在非首次进入的情况下先展示给用户可以看的内容，然后再从网络慢慢请求最新数据，最终提升应用冷启动速度 2 秒左右。